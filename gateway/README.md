## Introduction

Nginx configuration to distribute requests across services.

## Expose a feature on the gateway

### Gateway Introduction

By default, the service is only reachable from `misakey_vpn` network, if you have configured it this way. In order to expose the service to the external world, we use a reverse proxy.

The reverse proxy we use today is [nginx](https://www.nginx.com/resources/wiki/).

This reverse proxy is responsible for:
- handling different domains of our set of products.
- serving frontend static files.
- serving some backend APIs:
  - it forwards requests to corresponding service.
  - it handles authorization of request, transforming opaque access token to [JWT](https://tools.ietf.org/html/rfc7519) access token (calling an auth route).

This being said, it is logical that a route exposed to the external world should always be exposed through the gateway.

### Where to configure my feature

If the feature to expose is frontend oriented, you should serve static files to corresponding domain (you might create one).
If the feature to expose is backend oriented, you might add it to `auth` business domain (auth.misakey.com) or our `generic api` business domain (api.misakey.com).

The `auth` business domain serves both frontend and backend routes, this is why the gateway consider backend only routes starting by an underscore `_` (we rewrite the location for every route).

The gateway should be rebuild when modified to have changes applied (`docker-compose up --build gateway`).

### Gateway Authorization

Authorization is managed by [auth_request](http://nginx.org/en/docs/http/ngx_http_auth_request_module.html) module.

We send the `Authorization` header (opaque token) to our auth system which validate or not the token.

If the token is valid, the auth system transform it as a [JWT](https://tools.ietf.org/html/rfc7519) containing information. The [JWT](https://tools.ietf.org/html/rfc7519) is then forwarded to services by the gateway.
Contained information is about authorizations: who owns the token, what scope contains the token, what service should accept the token...).

To configure correctly your request authorization, you must be aware of our different types of access token and different routes of our auth system to handle them.

#### Classic Access Token

Classic Access Token are the most common and used tokens. They are generated by an Open ID Connect Flow (Authorization Code with Secret/Public Client).

They are opaque, and are the most trustable way of authorizing a request.

**In order to generate a classic access token**, you must perform the whole authorization flow, the easiest way is today to use the frontend interface, since lot of requests and redirection are done during the flow.

#### Authorization Routes

After seeing the kind of tokens we handle, here is the list of routes our gateway might use to authorize a request:

- `/auth`: strict authorization, classic access token only ([doc](https://docs.misakey.dev/backend/?urls.primaryName=Auth#/Private/get_auth)).
- `/auth-optional`: moderate authorization, classic access token only ([doc](https://docs.misakey.dev/backend/?urls.primaryName=Auth#/Private/get_auth_optional)).

## Deploy the Gateway on Kubernetes

The gateway image is built and deployed each time the repo is pushed. It generates 3 images:

- On `tags`
  - `registry.misakey.dev/misakey/misakey/gateway:<tag>`
- On `master`
  - `registry.misakey.dev/misakey/misakey/gateway:preprod`
  - `registry.misakey.dev/misakey/misakey/gateway:latest`


- Make sure the image you want to deploy exists
- In the `gateway` root directory, run:
  - If this is the first time
```
helm install --name nginx helm/gateway --set env=<env> --set image.tag=<tag> --set dns="<misakey.com|preprod.misakey.dev>"
```
  - If this is an upgrade
```
helm upgrade nginx helm/gateway --set env=<preprod|production> --set image.tag=<preprod|production> --set dns="<misakey.com|preprod.misakey.dev>"
```
- Check that the deployment went well by running `kubectl get pods`.
